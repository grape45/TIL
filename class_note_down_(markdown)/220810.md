## 0810 KDT Class_note_down

### 🎯 학습 목표 : 알고리즘

#### 1. 그래프 탐색 알고리즘

- 데이터 구조는 알고리즘의 재료가 되어 **문제를 해결**하는데 사용
- 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘



#### 2. 깊이 우선 탐색(DFS) vs 너비 우선 탐색(BFS)

```bash
# 스택 + 그래프 + 큐
1. 깊이 우선 탐색(Depth-First Search, DFS)
그래프 깊이를 우선 탐색, "스택" 개념 활용

2. 너비 우선 탐색(Breadth-First Search, BFS)
그래프 너비를 우선 탐색, "큐" 개념 활용
```

1. 깊이 우선 탐색(DFS, Depth-First Search)

- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동

- 루트 노드(혹은 다른 임의의 노드)에서 시작해 다음 분기(branch)로 넘어가기 전에 **해당 분기를 완벽하게 탐색**

- 미로탈출에 대입해보기(어느 한 쪽 길로 가장 깊에 들어갔다가, 막히면 다시 돌아와 다른 길을 탐색함)

- 모든 노드를 방문하고자 하는 경우 사용

- 너비 우선 탐색(BFS)보다 코드 구현이 간단하지만 검색 속도는 상대적으로 느림

- **스택 또는 재귀함수로 구현** -> **경우의 수, 순열과 조합** 문제에 적용

- 인접 행렬 혹은 인접 리스트 방식으로 표현 가능

  ```python
  # 인접 행렬
  graph = [
    [0, 1, 1, 0, 0, 0, 0],
    [1, 0, 0, 1, 1, 0, 0],
    [1, 0, 0, 0, 1, 1, 0],
    [0, 1, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 1],
    [0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0]
  ]
  
  # 인접 리스트
  graph = [
    [1, 2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
  ]
  ```

  > 각 정점을 방문했는지 여부를 판별할 방문 체크 리스트가 필요 !!
  >
  > 컴퓨터는 사람과 달리 각 정점을 방문한지 여부를 알 수 없음
  >
  > 따라서 `visited list` 를 구현해서 체크

  ```python
  visited = [False] * n 
  # n은 정점의 개수
  ```

- DFS 사이클

  1. 현재 정점 방문 처리
  2. 인접한 모든 정점 확인
  3. 방문하지 안흔 인접 정점 이동

- 반복문을 이용한 DFS

  ```python
  # DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 후입선출(LIFO)구조의 스택 활용
  
  graph = [
    [1, 2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
  ]
  ```

  ```python
  visited = [False]*n # 방문 처리 리스트 만들기
  
  def dfs(start):
    stack = [start] # 돌아갈 곳을 기록
    visited[start] = True # 시작 정점 방문 처리
    
    while stack: # 스택이 빌 때까지(돌아갈 곳이 없으때까지) 반복
      cur = stack.pop() # 현재 방문 정점(후입선출)
      
      for adj in graph[cur]: # 인접한 모든 정점에 대해
        if not visited[adj]: # 아직 방문하지 않았다면
          visited[adj] = True # 방문 처리
          stack.apeend(adj) # 스택에 넣기
          
  def(0) # 0번 정점에서 시작
  ```

- 참고문제 : [BOJ 2606][https://www.acmicpc.net/problem/2606]



2. 너비 우선 탐색(BFS, Breadth-First Search)

- 최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동
- 루트 노드(혹은 다른 임의의 노드)에서 시작해 **인접한 노드를 먼저 탐색**
- 두 노드 사이의 **최단 경로**를 찾고자 하는 경우 사용
- **큐를 이용해서 구현**



#### 3. DFS 문제 풀이

```python
# 인접 리스트로 표현한 그래프를 기준으로 구성
# [단계 1] 입력 값을 받아 인접 리스트를 생성
visited = [False] * N # 방문 처리 리스트 만들기

# [단계 2] 1번 컴퓨터를 시작 정점으로 DFS 진행
def dfs(start):
  visited[start] = True # 시장 정점 방문 처리
  stack = [start] # 돌아갈 곳을 기록
  
  while len(stack) != 0: # 스택이 빌 때까지(=돌아갈 곳이 없을때까지) 반복
    current = stack.pop() # 현재 방문 정점(LIFO)
    
    for adj in graph[current]:
      if not visited[adj]:
        visited[adj] = True
        stack.append(adj)
dfs(1)
```

> 참고 문제 : BOJ 2644 - 촌수계산, BOJ 2606 - 바이러스, BOJ 1063 - 킹



