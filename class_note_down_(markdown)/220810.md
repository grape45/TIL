## 0810 KDT Class_note_down

### 🎯 학습 목표 : 알고리즘

#### 1. 그래프 탐색 알고리즘

- 데이터 구조는 알고리즘의 재료가 되어 **문제를 해결**하는데 사용
- 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘

#### 2. 깊이 우선 탐색(DFS) vs 너비 우선 탐색(BFS)

1. 깊이 우선 탐색(DFS, Depth-First Search)

- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동

- 루트 노드(혹은 다른 임의의 노드)에서 시작해 다음 분기(branch)로 넘어가기 전에 **해당 분기를 완벽하게 탐색**

- 미로탈출에 대입해보기

- 모든 노드를 방문하고자 하는 경우 사용

- 너비 우선 탐색(BFS)보다 코드 구현이 간단하지만 검색 속도는 상대적으로 느림

- **스택 또는 재귀함수로 구현** -> **경우의 수, 순열과 조합** 문제에 적용

- 인접 행렬 혹은 인접 리스트 방식으로 표현 가능

  ```python
  # 인접 행렬
  graph = [
    [0, 1, 1, 0, 0, 0, 0],
    [1, 0, 0, 1, 1, 0, 0],
    [1, 0, 0, 0, 1, 1, 0],
    [0, 1, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 1],
    [0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0]
  ]
  
  # 인접 리스트
  graph = [
    [1, 2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
  ]
  ```

  > 각 정점을 방문했는지 여부를 판별할 방문 체크 리스트가 필요 !!
  >
  > 컴퓨터는 사람과 달리 각 정점을 방문한지 여부를 알 수 없음 -> visited list를 구현해서 체크

  ```python
  # 반복문을 이용한 DFS
  # DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 후입선출(LIFO)구조의 스택을 사용
  
  visited = [False] * n # 방문 처리 리스트 만들기
  
  visited[0] = 
  ```

  

2. 너비 우선 탐색(BFS, Breadth-First Search)

- 최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동
- 루트 노드(혹은 다른 임의의 노드)에서 시작해 **인접한 노드를 먼저 탐색**
- 두 노드 사이의 **최단 경로**를 찾고자 하는 경우 사용
- **큐를 이용해서 구현**



#### 3. DFS 문제 풀이

```python
# [단계 1] 입력 값을 받아 인접 리스트를 생성


# [단계 2] 1번 컴퓨터를 시작 정점으로 DFS 진행
```





