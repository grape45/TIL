## 0726 (오전)

### 🎯 오전 학습 목표 : 알고리즘 2

취업 위의 커리어, 커리어 위의 나의 삶 ⭐️

#### 1. 알고리즘의 시간 복잡도

- 좋은 알고리즘 ? == 효율성이 좋은? == 성능이 좋은? == Input 후 Output 도출 시간이 짧은 !
- 객관적인 측정을 위해 **알고리즘 내부에서** 기본연산이 몇 번 일어나는지 확인
  - 기본 연산 : 단위 시간 1이 소요되는 연산
    - 할당, 산술, 비교, 반환...
  - 기본 연산의 총 횟수 == 알고리즘의 소요 시간
- 성능 측정 시 입력을 통일시킴
  - 기본연산이 가장 많이 일어나는 **최악의 입력 n개**가 들어온다고 가정

- 시간 복잡도 (Time Complexity)
  - 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
  - 단순하게 <u>알고리즘의 수행 시간</u>
    - 시간 복잡도가 높다 -> 느린 알고리즘
    - 시간 복잡도가 낮다 -> 빠른 알고리즘



#### 2. Big-O 표기법

- 입력 n이 **무한대**로 커진다고 가정하고 시간 복잡도를 간단하게 표시

  - 최고차항만 남기고 계수와 상수 제거

  - 매 입력에 따라 정확한 수식을 구하는 것이 불가능
  - 정확한 수치보다 **증가율**에 초점

- 다양한 시간 복잡도

![0726](220726.assets/0726.jpeg)

```python
O(1) : 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈)
  # a + b, 100 * 200
  
O(logN) : 크기 N인 리스트를 반절씩 순회/탐색
  # 이진탐색(Binary Search), 분할정복(Divide & Conquer)

O(N) : 크기 N인 리스트를 순회
  # 1중 for문, count()
  ## 1초가 걸리는 입력의 크기 : 1억(기준)
  
O(NlogN) : 크기 N인 리스트를 반절씩 탐색 * 순회
  # 높은 성능의 정렬(Merge/Quick/Heap Sort)
  ## 1초가 걸리는 입력의 크기 : 500만
  
O(N^2) : 크기 M, N인 2중 리스트를 순회
  # 2중 for문
  ## 1초가 걸리는 입력의 크기 : 1만
  
O(N^3) : 3중 리스트를 순회
  # 3중 for문
  ## 1초가 걸리는 입력의 크기 : 500
  
O(2^N) : 크기 N인 집합의 부분 집합
  ## 1초가 걸리는 입력의 크기 : 20
  
O(N!) : 크기 N인 리스트의 순열
  ## 1초가 걸리는 입력의 크기 : 10
```

```python
# 방법 1: 1부터 n까지 일일이 더하기
def get_total(n):
  total = 0
  
  for i in range(1, n + 1):
    total += i
    
  return total

print(get_total(10))
# 55

print(get_total(100000000)
# 제한 시간 1초 초과
      
# 방법 2 : 가우스의 합 공식
def get_total(n):
      return (n * (n + 1)) // 2
      
print(get_total(10))
# 55

print(get_total(100000000)
# 50000000500000000
```

- 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 **성능**이 달라지고 시험에서 **정답** 여부가 갈린다.

```bash
✍🏻 for문을 1번만 사용했다고 해서 무조건 O(n)인 것이 아님 !!!

		for문 안에 O(n)의 내장 함수를 사용했다면 사실상 이중 for문과 다를 것이 없다.
```



#### 📌 한 장 그림 요약



## 0726(오후)

### 🎯 오후 학습 목표 : 실습 
